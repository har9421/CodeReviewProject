using CodeReviewBot.Domain.Entities;
using Microsoft.Extensions.Logging;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace CodeReviewBot.Infrastructure.ExternalServices;

public class DataPreprocessingService
{
    private readonly ILogger<DataPreprocessingService> _logger;
    private readonly List<string> _excludedPatterns;
    private readonly List<string> _testPatterns;
    private readonly List<string> _generatedCodePatterns;

    public DataPreprocessingService(ILogger<DataPreprocessingService> logger)
    {
        _logger = logger;

        // Patterns to exclude from analysis
        _excludedPatterns = new List<string>
        {
            @"\.generated\.cs$",
            @"\.designer\.cs$",
            @"\.g\.cs$",
            @"\.g\.i\.cs$",
            @"AssemblyInfo\.cs$",
            @"GlobalUsings\.cs$",
            @"obj/",
            @"bin/",
            @"packages/",
            @"\.vs/",
            @"\.git/",
            @"node_modules/",
            @"\.nuget/"
        };

        // Patterns for test files
        _testPatterns = new List<string>
        {
            @"test",
            @"spec",
            @"\.test\.",
            @"\.spec\.",
            @"Tests/",
            @"Specs/",
            @"TestHelpers/",
            @"Mock",
            @"Fake",
            @"Stub"
        };

        // Patterns for generated code
        _generatedCodePatterns = new List<string>
        {
            @"// <auto-generated",
            @"// This code was generated",
            @"// Generated by",
            @"#pragma warning disable",
            @"[GeneratedCode(",
            @"[CompilerGenerated]"
        };
    }

    public async Task<PreprocessedData> PreprocessPullRequestAsync(RawPullRequestData rawData)
    {
        try
        {
            _logger.LogInformation("Preprocessing PR {Number} from {Owner}/{Repo}",
                rawData.Number, rawData.Owner, rawData.Repository);

            var preprocessedData = new PreprocessedData
            {
                Id = Guid.NewGuid().ToString(),
                OriginalData = rawData,
                ProcessedAt = DateTime.UtcNow
            };

            // Clean and filter files
            var cleanedFiles = await CleanAndFilterFilesAsync(rawData.Files ?? new List<RawFileData>());
            preprocessedData.Files = cleanedFiles;

            // Extract meaningful changes
            var meaningfulChanges = ExtractMeaningfulChanges(cleanedFiles);
            preprocessedData.MeaningfulChanges = meaningfulChanges;

            // Analyze code patterns
            var patterns = AnalyzeCodePatterns(cleanedFiles);
            preprocessedData.CodePatterns = patterns;

            // Calculate quality metrics
            var metrics = CalculateQualityMetrics(cleanedFiles, rawData);
            preprocessedData.QualityMetrics = metrics;

            // Extract learning features
            var features = ExtractLearningFeatures(rawData, cleanedFiles);
            preprocessedData.LearningFeatures = features;

            _logger.LogInformation("Preprocessed PR {Number}: {FileCount} files, {ChangeCount} meaningful changes",
                rawData.Number, cleanedFiles.Count, meaningfulChanges.Count);

            return preprocessedData;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error preprocessing PR {Number}", rawData.Number);
            throw;
        }
    }

    private async Task<List<CleanedFileData>> CleanAndFilterFilesAsync(List<RawFileData> rawFiles)
    {
        var cleanedFiles = new List<CleanedFileData>();

        foreach (var file in rawFiles)
        {
            // Skip excluded files
            if (ShouldExcludeFile(file.Filename))
            {
                _logger.LogDebug("Excluding file: {Filename}", file.Filename);
                continue;
            }

            // Clean file content
            var cleanedContent = await CleanFileContentAsync(file.Content ?? "");
            if (string.IsNullOrEmpty(cleanedContent))
            {
                continue;
            }

            var cleanedFile = new CleanedFileData
            {
                Filename = file.Filename,
                OriginalContent = file.Content ?? "",
                CleanedContent = cleanedContent,
                IsTestFile = IsTestFile(file.Filename),
                IsGeneratedCode = IsGeneratedCode(cleanedContent),
                FileSize = cleanedContent.Length,
                LineCount = cleanedContent.Split('\n').Length,
                Language = DetectLanguage(file.Filename),
                ChangeType = file.Status ?? "modified",
                Additions = file.Additions,
                Deletions = file.Deletions
            };

            cleanedFiles.Add(cleanedFile);
        }

        return cleanedFiles;
    }

    private bool ShouldExcludeFile(string filename)
    {
        return _excludedPatterns.Any(pattern =>
            Regex.IsMatch(filename, pattern, RegexOptions.IgnoreCase));
    }

    private bool IsTestFile(string filename)
    {
        return _testPatterns.Any(pattern =>
            Regex.IsMatch(filename, pattern, RegexOptions.IgnoreCase));
    }

    private bool IsGeneratedCode(string content)
    {
        return _generatedCodePatterns.Any(pattern =>
            content.Contains(pattern, StringComparison.OrdinalIgnoreCase));
    }

    private async Task<string> CleanFileContentAsync(string content)
    {
        if (string.IsNullOrEmpty(content))
            return string.Empty;

        // Remove BOM
        content = content.TrimStart('\uFEFF');

        // Remove excessive whitespace
        content = Regex.Replace(content, @"\r\n|\r|\n", "\n");
        content = Regex.Replace(content, @"[ \t]+", " ");
        content = Regex.Replace(content, @"\n[ \t]+\n", "\n\n");

        // Remove comments that are too long (likely generated)
        content = RemoveExcessiveComments(content);

        // Remove empty lines at the beginning and end
        content = content.Trim('\n', '\r', ' ', '\t');

        return content;
    }

    private string RemoveExcessiveComments(string content)
    {
        // Remove comment blocks that are longer than 50 lines
        var lines = content.Split('\n');
        var cleanedLines = new List<string>();
        var inCommentBlock = false;
        var commentBlockStart = 0;

        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i];
            var trimmedLine = line.Trim();

            if (trimmedLine.StartsWith("/*"))
            {
                inCommentBlock = true;
                commentBlockStart = i;
            }
            else if (inCommentBlock && trimmedLine.EndsWith("*/"))
            {
                inCommentBlock = false;
                var commentLength = i - commentBlockStart + 1;

                // Only keep comment blocks that are reasonable in length
                if (commentLength <= 50)
                {
                    for (int j = commentBlockStart; j <= i; j++)
                    {
                        cleanedLines.Add(lines[j]);
                    }
                }
            }
            else if (!inCommentBlock)
            {
                cleanedLines.Add(line);
            }
        }

        return string.Join("\n", cleanedLines);
    }

    private string DetectLanguage(string filename)
    {
        var extension = Path.GetExtension(filename).ToLowerInvariant();
        return extension switch
        {
            ".cs" => "csharp",
            ".vb" => "vbnet",
            ".fs" => "fsharp",
            ".js" => "javascript",
            ".ts" => "typescript",
            ".py" => "python",
            ".java" => "java",
            ".cpp" => "cpp",
            ".c" => "c",
            ".h" => "c",
            _ => "unknown"
        };
    }

    private List<MeaningfulChange> ExtractMeaningfulChanges(List<CleanedFileData> files)
    {
        var changes = new List<MeaningfulChange>();

        foreach (var file in files)
        {
            if (file.Language != "csharp" || file.IsGeneratedCode)
                continue;

            // Extract method changes
            var methodChanges = ExtractMethodChanges(file);
            changes.AddRange(methodChanges);

            // Extract class changes
            var classChanges = ExtractClassChanges(file);
            changes.AddRange(classChanges);

            // Extract interface changes
            var interfaceChanges = ExtractInterfaceChanges(file);
            changes.AddRange(interfaceChanges);

            // Extract property changes
            var propertyChanges = ExtractPropertyChanges(file);
            changes.AddRange(propertyChanges);
        }

        return changes;
    }

    private List<MeaningfulChange> ExtractMethodChanges(CleanedFileData file)
    {
        var changes = new List<MeaningfulChange>();
        var methodPattern = @"(public|private|protected|internal)\s+(static\s+)?\w+\s+\w+\s*\([^)]*\)\s*{";
        var matches = Regex.Matches(file.CleanedContent, methodPattern, RegexOptions.Multiline);

        foreach (Match match in matches)
        {
            changes.Add(new MeaningfulChange
            {
                Type = ChangeType.Method,
                FilePath = file.Filename,
                Content = match.Value,
                LineNumber = GetLineNumber(file.CleanedContent, match.Index),
                Significance = CalculateSignificance(match.Value)
            });
        }

        return changes;
    }

    private List<MeaningfulChange> ExtractClassChanges(CleanedFileData file)
    {
        var changes = new List<MeaningfulChange>();
        var classPattern = @"(public|private|protected|internal)\s+(static\s+)?class\s+\w+";
        var matches = Regex.Matches(file.CleanedContent, classPattern, RegexOptions.Multiline);

        foreach (Match match in matches)
        {
            changes.Add(new MeaningfulChange
            {
                Type = ChangeType.Class,
                FilePath = file.Filename,
                Content = match.Value,
                LineNumber = GetLineNumber(file.CleanedContent, match.Index),
                Significance = CalculateSignificance(match.Value)
            });
        }

        return changes;
    }

    private List<MeaningfulChange> ExtractInterfaceChanges(CleanedFileData file)
    {
        var changes = new List<MeaningfulChange>();
        var interfacePattern = @"(public|private|protected|internal)\s+interface\s+\w+";
        var matches = Regex.Matches(file.CleanedContent, interfacePattern, RegexOptions.Multiline);

        foreach (Match match in matches)
        {
            changes.Add(new MeaningfulChange
            {
                Type = ChangeType.Interface,
                FilePath = file.Filename,
                Content = match.Value,
                LineNumber = GetLineNumber(file.CleanedContent, match.Index),
                Significance = CalculateSignificance(match.Value)
            });
        }

        return changes;
    }

    private List<MeaningfulChange> ExtractPropertyChanges(CleanedFileData file)
    {
        var changes = new List<MeaningfulChange>();
        var propertyPattern = @"(public|private|protected|internal)\s+(static\s+)?\w+\s+\w+\s*{\s*get;\s*set;\s*}";
        var matches = Regex.Matches(file.CleanedContent, propertyPattern, RegexOptions.Multiline);

        foreach (Match match in matches)
        {
            changes.Add(new MeaningfulChange
            {
                Type = ChangeType.Property,
                FilePath = file.Filename,
                Content = match.Value,
                LineNumber = GetLineNumber(file.CleanedContent, match.Index),
                Significance = CalculateSignificance(match.Value)
            });
        }

        return changes;
    }

    private int GetLineNumber(string content, int index)
    {
        return content.Substring(0, index).Split('\n').Length;
    }

    private double CalculateSignificance(string content)
    {
        // Simple significance calculation based on content length and keywords
        var keywords = new[] { "public", "async", "override", "virtual", "abstract" };
        var keywordCount = keywords.Count(keyword => content.Contains(keyword));
        var length = content.Length;

        return Math.Min(1.0, (keywordCount * 0.2) + (length / 1000.0));
    }

    private CodePatterns AnalyzeCodePatterns(List<CleanedFileData> files)
    {
        var patterns = new CodePatterns();

        foreach (var file in files)
        {
            if (file.Language != "csharp")
                continue;

            // Analyze naming conventions
            patterns.NamingConventionIssues += CountNamingConventionIssues(file.CleanedContent);

            // Analyze complexity
            patterns.ComplexityIssues += CountComplexityIssues(file.CleanedContent);

            // Analyze documentation
            patterns.DocumentationIssues += CountDocumentationIssues(file.CleanedContent);

            // Analyze error handling
            patterns.ErrorHandlingIssues += CountErrorHandlingIssues(file.CleanedContent);
        }

        return patterns;
    }

    private int CountNamingConventionIssues(string content)
    {
        var issues = 0;

        // Check for PascalCase violations in public members
        var publicMemberPattern = @"public\s+\w+\s+[a-z]";
        issues += Regex.Matches(content, publicMemberPattern).Count;

        // Check for camelCase violations in private members
        var privateMemberPattern = @"private\s+\w+\s+[A-Z]";
        issues += Regex.Matches(content, privateMemberPattern).Count;

        return issues;
    }

    private int CountComplexityIssues(string content)
    {
        var issues = 0;

        // Count long methods (simplified)
        var methodPattern = @"\w+\s+\w+\s*\([^)]*\)\s*{[^}]{200,}}";
        issues += Regex.Matches(content, methodPattern).Count;

        // Count deep nesting
        var nestingPattern = @"\{[^{}]*\{[^{}]*\{[^{}]*\{";
        issues += Regex.Matches(content, nestingPattern).Count;

        return issues;
    }

    private int CountDocumentationIssues(string content)
    {
        var issues = 0;

        // Count public methods without documentation
        var publicMethodPattern = @"public\s+\w+\s+\w+\s*\([^)]*\)\s*(?!\s*///)";
        issues += Regex.Matches(content, publicMethodPattern).Count;

        return issues;
    }

    private int CountErrorHandlingIssues(string content)
    {
        var issues = 0;

        // Count methods without try-catch
        var methodPattern = @"\w+\s+\w+\s*\([^)]*\)\s*{[^}]*}";
        var methods = Regex.Matches(content, methodPattern);

        foreach (Match method in methods)
        {
            var methodContent = method.Value;
            if (!methodContent.Contains("try") && !methodContent.Contains("catch"))
            {
                issues++;
            }
        }

        return issues;
    }

    private QualityMetrics CalculateQualityMetrics(List<CleanedFileData> files, RawPullRequestData prData)
    {
        var metrics = new QualityMetrics
        {
            TotalFiles = files.Count,
            CSharpFiles = files.Count(f => f.Language == "csharp"),
            TestFiles = files.Count(f => f.IsTestFile),
            GeneratedFiles = files.Count(f => f.IsGeneratedCode),
            TotalLines = files.Sum(f => f.LineCount),
            TotalAdditions = files.Sum(f => f.Additions),
            TotalDeletions = files.Sum(f => f.Deletions)
        };

        // Calculate complexity metrics
        metrics.AverageFileSize = files.Any() ? files.Average(f => f.FileSize) : 0;
        metrics.AverageLineCount = files.Any() ? files.Average(f => f.LineCount) : 0;
        metrics.LargestFile = files.Any() ? files.Max(f => f.FileSize) : 0;

        return metrics;
    }

    private LearningFeatures ExtractLearningFeatures(RawPullRequestData prData, List<CleanedFileData> files)
    {
        return new LearningFeatures
        {
            RepositoryType = DetermineRepositoryType(prData.Owner, prData.Repository),
            ProjectSize = EstimateProjectSize(files),
            CodeQuality = EstimateCodeQuality(files),
            ChangePattern = DetermineChangePattern(files),
            TechnologyStack = ExtractTechnologyStack(files),
            ComplexityLevel = EstimateComplexityLevel(files)
        };
    }

    private string DetermineRepositoryType(string owner, string repository)
    {
        // Simple heuristic to determine repository type
        if (owner.Contains("microsoft") || owner.Contains("dotnet"))
            return "framework";
        if (repository.Contains("test") || repository.Contains("spec"))
            return "test";
        if (repository.Contains("sample") || repository.Contains("example"))
            return "sample";
        return "application";
    }

    private int EstimateProjectSize(List<CleanedFileData> files)
    {
        var totalLines = files.Sum(f => f.LineCount);
        return totalLines switch
        {
            < 1000 => 1, // Small
            < 10000 => 2, // Medium
            < 50000 => 3, // Large
            _ => 4 // Very Large
        };
    }

    private double EstimateCodeQuality(List<CleanedFileData> files)
    {
        if (!files.Any())
            return 0.5;

        var qualityScore = 0.0;
        var totalFiles = files.Count;

        foreach (var file in files)
        {
            if (file.IsGeneratedCode)
                continue;

            var fileQuality = 1.0;

            // Penalize very large files
            if (file.LineCount > 500)
                fileQuality *= 0.8;

            // Penalize files without proper structure
            if (!file.CleanedContent.Contains("namespace") && file.LineCount > 50)
                fileQuality *= 0.9;

            qualityScore += fileQuality;
        }

        return qualityScore / totalFiles;
    }

    private string DetermineChangePattern(List<CleanedFileData> files)
    {
        var additions = files.Sum(f => f.Additions);
        var deletions = files.Sum(f => f.Deletions);
        var ratio = additions / (double)Math.Max(deletions, 1);

        return ratio switch
        {
            > 3 => "feature-addition",
            < 0.5 => "refactoring",
            _ => "mixed"
        };
    }

    private List<string> ExtractTechnologyStack(List<CleanedFileData> files)
    {
        var technologies = new HashSet<string>();

        foreach (var file in files)
        {
            if (file.Filename.Contains("EntityFramework") || file.CleanedContent.Contains("DbContext"))
                technologies.Add("EntityFramework");
            if (file.Filename.Contains("Controller") || file.CleanedContent.Contains("ControllerBase"))
                technologies.Add("ASP.NET");
            if (file.CleanedContent.Contains("async") && file.CleanedContent.Contains("await"))
                technologies.Add("AsyncProgramming");
            if (file.CleanedContent.Contains("LINQ") || file.CleanedContent.Contains(".Where("))
                technologies.Add("LINQ");
        }

        return technologies.ToList();
    }

    private int EstimateComplexityLevel(List<CleanedFileData> files)
    {
        var complexityScore = 0;

        foreach (var file in files)
        {
            if (file.Language != "csharp")
                continue;

            // Count complex patterns
            var asyncMethods = Regex.Matches(file.CleanedContent, @"async\s+\w+").Count;
            var linqQueries = Regex.Matches(file.CleanedContent, @"\.Where\(|\.Select\(|\.GroupBy\(").Count;
            var generics = Regex.Matches(file.CleanedContent, @"<\w+>").Count;

            complexityScore += asyncMethods + linqQueries + generics;
        }

        return complexityScore switch
        {
            < 10 => 1, // Low
            < 50 => 2, // Medium
            < 100 => 3, // High
            _ => 4 // Very High
        };
    }
}

// Data models
public class RawPullRequestData
{
    public int Number { get; set; }
    public string Title { get; set; } = string.Empty;
    public string Body { get; set; } = string.Empty;
    public string Owner { get; set; } = string.Empty;
    public string Repository { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public List<RawFileData>? Files { get; set; }
}

public class RawFileData
{
    public string Filename { get; set; } = string.Empty;
    public string? Content { get; set; }
    public string? Status { get; set; }
    public int Additions { get; set; }
    public int Deletions { get; set; }
}

public class PreprocessedData
{
    public string Id { get; set; } = string.Empty;
    public RawPullRequestData OriginalData { get; set; } = new();
    public List<CleanedFileData> Files { get; set; } = new();
    public List<MeaningfulChange> MeaningfulChanges { get; set; } = new();
    public CodePatterns CodePatterns { get; set; } = new();
    public QualityMetrics QualityMetrics { get; set; } = new();
    public LearningFeatures LearningFeatures { get; set; } = new();
    public DateTime ProcessedAt { get; set; }
}

public class CleanedFileData
{
    public string Filename { get; set; } = string.Empty;
    public string OriginalContent { get; set; } = string.Empty;
    public string CleanedContent { get; set; } = string.Empty;
    public bool IsTestFile { get; set; }
    public bool IsGeneratedCode { get; set; }
    public int FileSize { get; set; }
    public int LineCount { get; set; }
    public string Language { get; set; } = string.Empty;
    public string ChangeType { get; set; } = string.Empty;
    public int Additions { get; set; }
    public int Deletions { get; set; }
}

public class MeaningfulChange
{
    public ChangeType Type { get; set; }
    public string FilePath { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
    public int LineNumber { get; set; }
    public double Significance { get; set; }
}

public enum ChangeType
{
    Method,
    Class,
    Interface,
    Property,
    Field,
    Enum,
    Struct
}

public class CodePatterns
{
    public int NamingConventionIssues { get; set; }
    public int ComplexityIssues { get; set; }
    public int DocumentationIssues { get; set; }
    public int ErrorHandlingIssues { get; set; }
}

public class QualityMetrics
{
    public int TotalFiles { get; set; }
    public int CSharpFiles { get; set; }
    public int TestFiles { get; set; }
    public int GeneratedFiles { get; set; }
    public int TotalLines { get; set; }
    public int TotalAdditions { get; set; }
    public int TotalDeletions { get; set; }
    public double AverageFileSize { get; set; }
    public double AverageLineCount { get; set; }
    public int LargestFile { get; set; }
}

public class LearningFeatures
{
    public string RepositoryType { get; set; } = string.Empty;
    public int ProjectSize { get; set; }
    public double CodeQuality { get; set; }
    public string ChangePattern { get; set; } = string.Empty;
    public List<string> TechnologyStack { get; set; } = new();
    public int ComplexityLevel { get; set; }
}
